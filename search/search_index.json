{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-hiphyengine","title":"Welcome to HiPhyEngine!","text":"<p>HiPhyEngine is fast, feature-complete, all-in-one multi-physics simulation engine designed for full artistic control without compromising performance. It has many exclusive features that are not available in any other commercial simulators.</p> <p></p> <code>Designed for Performance</code> <p>HiPhyEngine is parallelized and vectorized to fully utilize all CPU cores. Even with the complex collisions, each frame will only take seconds.</p> <p>(1)</p> <ol> <li>See the sample videos. The timing is measured on an AMD AI Max 395 cpu.</li> </ol> <code>Full Artistic Control</code> <p>HiPhyEngine gives user full artistic controls. Most simulation parameters can be animated and mapped. In Blender, user can utilize attributes and geometric nodes to create animated simulation parameter maps for HiPhyEngine. HiPhyEngine also provides integration with the expression language SeExpr2 to give user more ways to create force fields and attributes.</p> <p></p> <code>Your All in One Solver</code> <p>HiPhyEngine is a fully coupled simulation engine for five different material models. Need to couple cloth and rigid body? Cloth and hairs? Soft bodies? No need for the extra set up! HiPhyEngine will take care of all the interactions!</p> <code>Robust and Clean Simulation Result</code> <p>HiPhyEngine guarantees intersection free simulation. No matter how fast things are moving, how thin, if there is a intersection-free solution, HiPhyEngine will find it! To give user maximum control, user can use animated maps to activate/deactive collision on demand anywhere, at any frame.</p> <code>Special Features</code> <p>Gravity is pulling your carefully groomed hairs down? No worries! HiPhyEngine has an inverse simulation technique that automatically generates the rest shape that compensates for gravity and other external forces. Animators are handing you meshes that go through themselves? No worries! HiPhyEngine's soft collider feature will automatically clean up incoming animation mesh makes them intersection free and ready for simulation. HiPhyEngine also has solver space, unit conversion, time scale, and tons of other features to explore!</p> <p></p>"},{"location":"aux-nodes/constraints-in-blender/","title":"Constraints in Blender","text":""},{"location":"aux-nodes/constraints-in-blender/#constraints-in-blender","title":"Constraints In Blender","text":"<p>HiPhyEngine provides multiple different constraint types. It provides both gui and python api for authoring the constraints as well.</p>"},{"location":"aux-nodes/constraints-in-blender/#point-constraint-and-mesh-constraints","title":"Point Constraint and Mesh Constraints","text":"<p>Point constraint and mesh constraints limit the movements of the choosen constraint points. Mesh constraint will deform and move with an associated mesh, while point constraint is composed of isolated points without any association to any mesh.</p> <p>Point constraint can be created in both object mode and edit mode right click menu. While mesh constraint can be created in object mode right click menu.</p> <p>To create a point constraint, first enters edit mode, select the points that the user wishes to constraint, right click-&gt;Hi Phy Create Mesh Constraint</p> <p>The point constraint can be animated to move the constraint point. Example here.</p> <p>To create a mesh constraint, first select a triangulated constraint mesh, then select the simulation object that the user wishes to constraint. User may enters edit mode select the points user wish to constraint or stay in object mode to use the automatic closest point binding. right click-&gt;Hi Phy Create Mesh Constraint.</p> <p>In edit mode, HiPhyEngine will automatically bind the selected point to the closest point on the constraint object.</p> <p>In object mode, HiPhyEngine will ask for a binding radius and automatically pick the vertices on the simulation object within the radius of the collision object.</p> <p>Mesh constraint will automatically follow the constraint mesh during frame change. The constraint mesh can be animated to move the constraint point. Example here. </p> <p>Animating the mesh constraint</p> <p>User should always bind the mesh constraint at the start frame. Do not move the the mesh constraint after binding at the start frame to prevent instability introduced by a sudden jump at the first frame. Feel free to animate/deform the mesh constraint after the start frame. HiPhyEngine will automatically update the mesh constraint points to follow the mesh deformation based on the barycentric weights embeded on the mesh surface when the frame changes. This ensures HiPhyEngine to get the correct constraint position during simulation export. </p>"},{"location":"aux-nodes/constraints-in-blender/#root-constraint","title":"Root Constraint","text":"<p>Root constraint are a special type of constraint specically designed for elastic rod. It not only constraints the position but also the frame of the rods. Binding the root constraint the same as binding the mesh constraint in the object mode. Select the simulation object (curves) and the constraint mesh, right click-&gt;Hi Phy Create Root Constraint. HiPhyEngine will automatically find the closest point on the constraint mesh to bind the first two vertices of each curve.</p>"},{"location":"aux-nodes/constraints-in-blender/#binding-constraint","title":"Binding Constraint","text":"<p>Binding constraint is designed for connecting two simulation objects. A common usage would be stiches between different cloth patches.</p> <p>Similar to mesh constraint, binding Constraint automatically find points between two simulation objects that are within the given binding radius and create a constraint between them. Binding constraint's creation menu provided two additional parameters Zero Rest Length Binding and Curve Can Bind Itself</p> <p>Zero Rest Length Binding create a binding constraint that with zero rest length between them. It is perfect for creating cloth stitches that is meant to be as close as possible. You can find an example for zero rest length binding constraint here</p> <p>Curve Can Bind Itself option allows each curve in a Blender curves object to bind with itself during binding. Each elastic rod curve can hold its own shape with bend and twist bending, so there is usually no reason to try to bind a curve with itself.</p>"},{"location":"aux-nodes/constraints-in-blender/#joint-constraint","title":"Joint Constraint","text":"<p>Joint constraint is a special constraint type for creating a joint on a single affine body or between two affine bodies. When created for a single affine body, it allows the affine body to rotate around the joint while holding the joint location. When created between affine bodies, it makes the two affine bodies linked at the joint. </p> <p>The Joint Location in the joint constraint creation menu is taken from the Blender Cursor.</p> <p>!! note \"Joint Location\"    The joint location does not have to be on either of the affine body. It can be any place in the 3D space. The simulator will bind an imaginary point from the object space of the affine body to the joint.</p> <p>!! note \"Axial Rotation\"    If user wish to restrict the axial rotation of a affine body, two joint constraints can be created on the axis of interest to achieve that.</p> <p>An example for joint constraint can be found here.</p> <p>!! note \"Constraint on soft collider\"    Soft collider only supports binding constraint</p>"},{"location":"aux-nodes/constraints-in-blender/#constraint-parameters","title":"Constraint Parameters","text":"<p>Almost all constraints shares the same set of constraints, with come caveats. Constraints can be either hard constraint or soft constraint.</p> <p>Hard constraints will be enforced exactly in the simulation. All root constraints are hard constraints, point constraint and mesh constraint for cloth and elastic rod can be hard constraints or soft constraints.</p> <p>Soft constraints are enforced approximately in the simulation by behaving as a spring force. The constraint parameter defines the parameter for the constraint force. point constraint and mesh constraint for cloth and elastic rod can be hard constraints or soft constraints. point constraint and mesh constraint for affine body and deformable body must be soft constraints. All binding constraints and joint constraints are soft constraints.</p> <p>!! note \"Numerical stability of hard constraints\"    It is not recommended to use hard constraints for if the constraints forces to stretch the material. They may create undesirable large deformation around the constraints. Soft constraint will produce much smoother results.</p> Property Name Description Unit Is Mappable Is Animatable Is Soft If the constraint is soft or not YES Is Enabled If the constraint is enabled or not YES Live Update (binding constraints only). Whether or not to deform the constraint point with the simulation mesh for visualization Constraint Compression Stiffness The spring stiffness when the constraint is compressed \\(10\\mu N/cm = g/s^2\\) YES YES Constraint Stretch Stiffness The spring stiffness when the constraint is stretched \\(10\\mu N/cm = g/s^2\\) YES YES Constraint Damping The damping factor for the constraint spring force. \\(1\\) is critical damping \\(1/s\\) YES YES <p>Mappable Constraint Parameters</p> <p>The spring parameters for constraints are mappable. Similar to the mappable parameters on a simulation object, user can control the constraints parameters using a per-point Blender attribute on the constraint object (not the simulation object that is been constraint). </p>"},{"location":"aux-nodes/constraints-in-blender/#python-api","title":"Python API","text":"<p>To enable user to fully customize the constraint authoring workflow, user can create their own custom constraint calibration workflow, and use the provided Blender Python API to create the constraint objects.</p>"},{"location":"aux-nodes/constraints-in-blender/#point-constraint","title":"Point constraint","text":"<pre><code>from HiPhy.utils import create_point_constraint\n# obj: the reference to the simulation object\n# verts: list of vertices to be constrained\n# name: name for the constraint\n# operator: (optional) a Blender operator to report error messages\ncreate_point_constraint.createPointConstraintObject(obj, verts, name, operator)\n</code></pre>"},{"location":"aux-nodes/constraints-in-blender/#mesh-constraint","title":"Mesh constraint","text":"<pre><code>from HiPhy.utils import create_mesh_constraint\n# sim_obj: the reference to the simulation object\n# mesh_obj: the reference to the mesh object\n# name: name for the constraint\n# bond_indices: the indices of the vertices in the simulation object for the constraint\n# bond_points: the position of the vertices in the simulation object for the constraint, in the world space\n# bond_face_ids: the id for the face of the mesh object bond by each constraint vertices\n# bond_barycentric_weights_on_mesh: the barycentric weight for closest point on the mesh object bond by each constraint vertices\n# bond_local_coord: the local coordinate for each constraint vertices in each bond mesh face frame.\n#                   If the three vertices of the mesh face are (v1, v2, v3), the frame (u, v, n) is defined as\n#                   u = (v2 - v1).Normalized()\n#                   n = u.Cross((v3 - v1)).Normalized()\n#                   v = n.Cross(u)\ncreate_mesh_constraint.createMeshConstraintObject(sim_obj, mesh_obj, name, bond_indices, bond_points, bond_face_ids, bond_barycentric_weights_on_mesh, bond_local_coord)\n</code></pre>"},{"location":"aux-nodes/constraints-in-blender/#root-constraint_1","title":"Root constraint","text":"<p>Root constraints are special, we do not provide a custom calibration API.</p>"},{"location":"aux-nodes/constraints-in-blender/#bind-constraint","title":"Bind constraint","text":"<pre><code>from HiPhy.utils import create_bind_constraint\n# name: name for the constraint\n# sim_obj_1: the reference to the first simulation object\n# sim_obj_2: the reference to the second simulation object\n# indices1: the indices of the vertices of the first simulation object for each bond primitive\n# indices2: the indices of the vertices of the second simulation object for each bond primitive\n#           bind constraints bind primitive to primitive (triangle to triangle, curve segment to curve segment, or triangle to curve segment)\n#           indices for each primitives must be a triplet such as [v1, v2, v3] for triangle faces, [v1, v2, v1] for curve segment (the duplicated indices serves a sentinel value)\n# binding_positions1: the position of the vertices in the first simulation object for the constraint, in the world space\n# binding_positions2: the position of the vertices in the first simulation object for the constraint, in the world space\n# weights1: the barycentric weight/linear weight for binding_positions of each binding point for the first simulation object.\n# weights2: the barycentric weight/linear weight for binding_positions of each binding point for the second simulation object.\n#           the weights are triplets as well.\n#           if the simulation object is a triangle mesh, it will be the barycentric weight [w1, w2, w3].\n#           if the simulation object is a curve, it will be the linear weight [w1, w2, 0].\n# zero_length_binding: if the binding constraint is zero rest length. If false, the distance between the binding_positions will be used to compute the rest length of the constraint.\ncreate_bind_constraint.createBindConstraintObject(name, sim_obj_1, sim_obj_2, indices1, indices2, binding_positions1, binding_positions2, weights1, weights2, zero_length_binding)\n</code></pre>"},{"location":"aux-nodes/constraints-in-blender/#joint-constraint_1","title":"Joint constraint","text":"<pre><code>from HiPhy.utils import create_joint_constraint\n# sim_obj_1: the reference to the first simulation object\n# sim_obj_2: the reference to the second simulation object, if the joint constraint is for a single affine body, this is None\n# joint_location: the location for the joint in world space \n# name: name for the constraint\ncreate_joint_constraint.createCreateConstraint(sim_obj_1, sim_obj_2, joint_location, name, operator = None):\n</code></pre>"},{"location":"aux-nodes/force-field-and-expression-in-blender/","title":"Force Field and Expression in Blender","text":""},{"location":"aux-nodes/force-field-and-expression-in-blender/#force-field-and-expression-in-blender","title":"Force Field and Expression in Blender","text":"<p>HiPhyEngine supports force field and expression to enable user to procedually create maps and external forces. The expression language used is SeExpr2. Expression language provide an simple way for artists to programmably create a per-point value for simulation.</p>"},{"location":"aux-nodes/force-field-and-expression-in-blender/#force-field","title":"Force Field","text":"<p>For visualization purposes, force field objects must be a mesh objects. In the examples, we used a plane as the force field object. Enable Hi Phy in the Physics panel and select Force Field, it will make the object a force field object for HiPhyEngine.</p>"},{"location":"aux-nodes/force-field-and-expression-in-blender/#simulation-parameters","title":"Simulation Parameters","text":"<p>The solver parameter is the solver object associated with the force field.</p> <p>The expression parameter is the SeExpr expression for the force field. Force field expression currently supports $P (vertex position), and $time (time) variables. The expression must be of the type Vector3.</p> <p>$P space</p> <p>The $P is the vertex position in the force field. It is intended so that user can use the transform of the force field object to move and rotate the generated force field without change the expression itself.</p> <p>The multiplier parameter applies a single scalar factor to scale up the force field expression. It is for a fast way to scale up the force value uniformly without adjusting the expression.</p> <p>$time</p> <p>$time is the time inside the simulator, respecting the solver's frame rate and time scale parameter. It is intended so that when force field is evaluated during simulation, the $time will match the visualization.</p> <p>The unit of the force field</p> <p>Dispite of the name, the unit for force field is \\(10\\mu N/cm^2\\) (presure) for mesh objects (affine body, cloth, and deformable body), \\(10\\mu N/cm\\) for curve objects (elastic rod). It is so that the force field's influence is resolution independent.</p> <p>The applies to parameter is a list of all objects that the force field influences. For each object, user can apply a different weight. Please make sure the simulation object is in the same solver as the force field.</p>"},{"location":"aux-nodes/force-field-and-expression-in-blender/#visualization-parameters","title":"Visualization Parameters","text":"<p>To visualize the force field, user can use the visualization parameters, set a range and number of slice. Click Update Visualization Mesh to update the force field mesh. When Live Update is checked, the visualization mesh will also automatically update with the change of frame.</p> <p>An example for using the forcefield can be find here.</p>"},{"location":"aux-nodes/force-field-and-expression-in-blender/#expression-attributes","title":"Expression Attributes","text":"<p>HiPhyEngine supports using per point attribute for the mappable properties. User can use tools in Blender to create and animate the attributes. We also provide a tool for user to create point attributes using SeExpr expressions.</p> <p>To create expression attribute, enable Hi Phy in the Physics panel. Creating expression attribute does not require the object to be a HiPhy simulation object.</p> <p>User can create any number of expression attributes, by adding them to the list. HiPhyEngine will automatically parse the expression and create the attribute with the proper type. The expression attribute currently supports $P, $t, $u, $v and $time (time) variables. $P is evaluated as the position attribute, $t is evaluated as the hi_phy_parameterization attribute, $u is evaluated as the hi_phy_u attribute, $v is evaluated as the hi_phy_v attribute, $time is the current scene time. In addition to the parameters above, we provides three float and three vector attributes as arbitrary inputs. The three float attributes are $v1, $v2, and $v3. They are evaluated as hi_phy_v1, hi_phy_v2, and hi_phy_v3. The three vector attributes are $vv1, $vv2, and $vv3. They are evaluated as hi_phy_vv1, hi_phy_vv2, and hi_phy_vv3. All the attributes must be per-vertex (point domain).</p> <p>$u and $v</p> <p>$u is evaluated as the hi_phy_u attribute, $v is evaluated as the hi_phy_v attribute. Not the hi_phy_cloth_uv attribute. This is intented to decouple the cloth material parameterization from the expression parameter, to give user more control over the expressions.</p> <p>$time</p> <p>Different from the force field, expression attribute are not associated with a solver, and is evaluated in Blender (instead of inside the simulator like the force fields). So the $time here is the scene time, not the simulator time.</p> <p>User can use the Evaluate Expression Attribute button to manually evaluate the expression at the current time and set to the corresponding Blender attribute. Or with the Live Update option checked, the attributes will be automatically updated with frame change.</p> <p>To use the expression attribute for simulation, it follows the same process as other mappable properties. Check the box next to the simulation property in question, then type in the attribute name will be used for that property.</p> <p>An example for expression attribute can be found here</p>"},{"location":"aux-nodes/property-map-in-blender/","title":"Property Map in Blender","text":""},{"location":"aux-nodes/property-map-in-blender/#property-map-in-blender","title":"Property Map in Blender","text":"<p>Most of the properties in HiPhyEngine are mappable. It means that these properties can be defined using a per-vertex (point domain) attribute. To enable maps, user just need to check the box next to the property, then input the desired attribute name. In most case, the attribute will need to be on the simulation object, with the exception of the mesh bones. For properties that are also animatable, user can animate those attribute using geometry nodes, modifier, or python scripts. During export, HiPhyEngine will go through the time line and pick up the animated attributes.</p> <p>Can Collider With Other Simulation Object/Colliders</p> <p>Can Collider With Other Simulation Object/Colliders are boolean attributes. However they are still mappable and animatable, to allow user turn on\\off collision at any frame as needed for each face. It is a per vertex attribute. A face will only participating collision, if all of its three vertices (two in the case of rods) has collision active.</p>"},{"location":"aux-nodes/solver/","title":"Solver","text":""},{"location":"aux-nodes/solver/#solver","title":"Solver","text":"<p>Solver nodes manage all global simulation parameters, simulation states, and the simulation cache. HiPhyEngine allows multiple solvers in the same scene. Though HiPhyEngine allows full coupling of all different material models, for performance and artistic iterative workflow, when possible, it is still recommended to split out different materials (such as hair, cloth, and body of the same character).</p>"},{"location":"aux-nodes/solver/#solver-space","title":"Solver Space","text":"<p>Solver node can be represented by any type of object. In the quick-start example, we used an empty axis object in Blender. Though the solver node is not rendered, the transformation of the solver node is still critical to the simulation. It defines the solver space. The solver space, is the object space of the solver node, it defines where the solver consider the origin, orientation, and scale is in the simulation.</p> <p>A common use of the solver space is for reducing numerical issues. For instance, if the shot is far from the origin (for instance, 1000s of units off), in such cases, the numerical effectiveness of the simulator will be significantly reduced, if the simulation runs in the world space. However, by moving the solver node to where the shot is, this numerical issue can be significantly mitigated.</p> <p>Another use of the solver space is to reduce motion introduced by animation using animated solver space. For instance, a character running or turning at a fast speed, to reduce or remove the motion introduced by such motion, user can make the solver node follow the animated character, this can remove/reduce the motion's effect on the simulation.</p> <p>Scaling the solver node</p> <p>DO NOT introduce scaling on the solver node, especially non-uniform scaling. The simulator will accept it as input, but there is no guarantee all parameters will be scaled accordingly. If you wish to scale the simulation space, for instance, for the purpose of unit conversion, use the solver scale parameter.</p> <p>You can find an example of multi-solver set up, and moving solver space here. In the example, you can see the moving solver space eliminated the effect of the moving point constraint. </p>"},{"location":"aux-nodes/solver/#solver-scale-and-model-unit","title":"Solver Scale, and Model Unit","text":"<p>The internal length unit of HiPhyEngine is \\(cm\\). Instead of requiring users to manually convert all parameters to \\(cm\\), HiPhyEngine provides a single parameter, solver scale, for unit conversion. For instance, if the scene is in \\(inch\\), user can set the solver scale to \\(2.54\\), then HiPhyEngine will internally scale up the scene by \\(2.54\\), effectively converts the units from \\(inch\\) to \\(cm\\).</p> <p>Some parameters in HiPhyEngine is labeled as model units instead of standard cm. Those parameters will be scaled with solver scale internally. The reason for HiPhyEngine to use model unit instead of cm is to make it easier for user to measure those parameters in the scene. For instance, collision thickness/radius and deformable body grid size are measured in model unit.</p>"},{"location":"aux-nodes/solver/#cache-management","title":"Cache Management","text":"<p>Each solver node owns and manages their own simulation cache (Please make sure the caches are pointing to different directories). In Blender, user has to manually save/load the cache file. It is due to the limitation of python API, we can't get a call back from blender when it closes to automatically save a dirty cache. To minimizing confusion, we have decided to just let the user manually manage the cache files. HiPhyEngine cache save/load are registered Blender operators too, so user can also write simple scripts to manages the cache IO when there are multiple solver nodes.</p>"},{"location":"aux-nodes/solver/#properties","title":"Properties","text":"Property Name Description Simulate In Memory If unchecked, the simulator will offload unused data to disk to minimize memory footprint <p>HiPhyEngine have to cache the whole simulation timeline and stores necessary intermediate data for simulation restarts. It can be very memory consuming, especially for volumetric simulations with deformable bodies. Unchecking the simulate in memory will allow the HiPhyEngine to offload unused data in the cache folder, and load them back in when requested.</p> Property Name Description Animatable Frame Start The start frame of the simulation Frame End The end frame of the simulation Solver Scale Scale factor between the scene and the solver space YES Number of Subframes Number of substeps inside each frame YES Frame Rate Number of frames per second YES Perform curve curve continuous time collision If continuous time collision will be performed for elastic rods. see elastic rods for more detail YES Newton Tolerance The order of error reduction for the Newton iteration YES CG Tolerance The order of error reduction for the linear solve iteration YES Max Newton Iterations The maximum number of Newton iterations the solver will perform YES Max Continuous Time Iterations The maximum number of continuous collision detection iteration the solver will perform YES"},{"location":"aux-nodes/solver/#number-of-subframes","title":"Number of Subframes","text":"<p>The default value for the number of subframes is \\(10\\). It is a very conservative setting that will create stable simulation in most cases. The number of subframes has the most drastic effect on the simulation time, user can choose to reduce the number of subframes to improve the simulation speed.</p>"},{"location":"aux-nodes/solver/#subframe-interpolation","title":"Subframe interpolation","text":"<p>HiPhyEngine exports the simulation data at each frame, and linearly interpolate the subframes inside the simulator. HiPhyEngine currently does not support export subframe data from rig. If the animation input has a large rotation within a frame, HiPhyEngine will not be able to handle it properly, user will need to manually increase the frame rate for the scene, stretch out the frames and pass it into the simulator with corresponding frame rate (don't forget to reduce the number of subframes as well).</p>"},{"location":"aux-nodes/solver/#solver-tolerance-and-simulation-performance","title":"Solver Tolerance and Simulation Performance","text":"<p>Lower the tolerance is, longer the simulation will need to run to achieve that. The default values are set as conservative. They will make sure the simulation will run through in the vast majority of the cases, however, they are also overly safe for most cases. If the simulation rig is too slow, those are the parameters need to be tuned. Smaller tolerance will run significantly faster, but might introduce jitters and other instabilities. Those tolerance are also animatable, so during shot work, user can selectively reduce the tolerance if they see instability in certain frames.</p> <p>An example output of the simulation might look like:</p> <pre><code>Newton iteration 0: 67.2891, step size: 1. CG iteration: 0\nNewton iteration 1: 6.89694, step size: 1. CG iteration: 9\nNewton iteration 2: 2.23009, step size: 1. CG iteration: 9\nNewton iteration 3: 0.273542, step size: 1. CG iteration: 7\nNewton iteration 4: 0.00789377, step size: 1. CG iteration: 8\nNewton iteration 5: 0.000133047, step size: 1. CG iteration: 9\nNewton iteration 6: 6.69312e-06, step size: 1. CG iteration: 9\nNewton iteration 7: 1.41424e-07, step size: 1. CG iteration: 10\n</code></pre> <p>User should see the Newton iteration goes down steadily. If the Newton iteration does not converge (i.e. reducing), user might need to reduce the CG tolerance.</p> <p>Please see deformable body for the grid parameters. Please see elastic rod for the preloading.</p>"},{"location":"material-models/affine-body/","title":"Affine Body","text":""},{"location":"material-models/affine-body/#affine-body","title":"Affine Body","text":"<p>Affine body is the material model for simulating stiff materials. Affine body objects must be triangulated meshes.</p>"},{"location":"material-models/affine-body/#related-objects","title":"Related Objects","text":"<code>Solver</code> <p>The Solver object for the simulation.</p> <code>Driven Shape</code> <p>As noted in overview, in Blender, the simulation cache directly deforms the point attribute before any modifier is applied. While during export, all modifiers of the simulation object is applied. This means that having any modifiers on the simulation object that changes point position or vertex count on the simulation object will leads to a discrepancy between the simulation mesh and the simulation cache. Driven Shape is designed to bypass this limitation. If user wish to apply modifiers after the simulation result, user can apply the modifiers to the Driven Shape instead of the simulation object. When Driven Shape is set, the simulation will export from the simulation object, but deforms the Driven Shape (instead of the simulation object).</p>"},{"location":"material-models/affine-body/#material-properties","title":"Material Properties","text":"Property Name Description Unit Is Mappable Is Animatable Can Collide With Other Simulation Object Can this simulation object collide with other simulation objects YES YES Can Collide With Colliders Can this simulation object collide with kinematic colliders YES YES Gravity The gravitational acceleration \\(cm/s^2\\) YES External Force Additional external force \\(10\\mu N = g*cm/s^2\\) YES Inner Thickness The thickness along the negative normal direction Model YES YES Outer Thickness The thickness along the positive normal direction Model YES YES Inner Friction Coefficient The friction coefficient for the inside Unitless YES YES Outer Friction Coefficient The friction coefficient for the outside Unitless YES YES Barrier Stiffness The stiffness of the collision barrier for contact \\(10\\mu N = g*cm/s^2\\) YES YES Density Surface density of the affine body object \\(g/cm^2\\) YES Stiffness Material stiffness of the affine body \\(100 nJ = g*cm^2/s^2\\) YES Mass Damping Damping of all motion of the affine body \\(1/s\\) YES <p>Model Unit</p> <p>Model unit is a special unit that does not scale with the solver scale. See solver for more detail.</p> <p>Density</p> <p>Affine body density is computed using the surface area, not the volume. So the density attribute is of unit \\(g/cm^2\\) not \\(g/cm^3\\)</p> <p>Friction Coefficient</p> <p>Friction coefficients are multiplicative. If a surface  with friction coefficient \\(0.1\\) comes in contact with another surface of friction coefficient \\(0.1\\), the resulting friction coefficient is \\(0.1 \\times 0.1 = 0.01\\)</p> <p>Barrier Stiffness</p> <p>The contact stiffness of barrier has the unit of \\(10\\mu N\\) instead of \\(10\\mu N/cm\\). It ensures that the contact stiffness is thickness invariant, i.e. user will not need to change the contact stiffness if the thickness of the object has changed to ensure the contact barrier exerts the same amount of force.</p> <p>Stiffness</p> <p>Affine body should have very high stiffness value, the default stiffness value reflects that. During contact or simulation, the affine body can deform slightly (invisible to the human eye), such deformation allows it to be couple with other deformable materials easily. In general, we want the stiffness to be high enough so the deformation will be hidden visually.</p>"},{"location":"material-models/affine-body/#examples","title":"Examples","text":"<p>You can find the an example file for affine body simulation here. It comes with a script to create generate a stacked affine body walls.</p>"},{"location":"material-models/cloth/","title":"Cloth","text":""},{"location":"material-models/cloth/#cloth","title":"Cloth","text":"<p>Cloth is the material model for simulating curves. Cloth objects in Blender must be triangulated mesh objects.</p> <code>Solver</code> <p>The Solver object for the simulation.</p> <code>Rest Shape</code> <p>The Rest Shape is the object for defining the shape at rest. The simulation object will returns to the Rest Shape when there is no external force. When no Rest Shape is specified, the start frame of the simulation object is used as the Rest Shape. Rest Shape needs to have the same number of vertices as the simulation object.</p> <code>Target Shape</code> <p>During simulation, the Target Shape creates a force to pull the simulation object towards the Target Shape. It designed for achieving art directed shape during motion. The strength of the pulling force is controlled Target Stiffness and Target Damping parameter. Target Shape needs to have the same number of vertices as the simulation object.</p> <code>Driven Shape</code> <p>As noted in overview, in Blender, the simulation cache directly deforms the point attribute before any modifier is applied. While during export, all modifiers of the simulation object is applied. This means that having any modifiers on the simulation object that changes point position or vertex count on the simulation object will leads to a discrepancy between the simulation mesh and the simulation cache. Driven Shape is designed to bypass this limitation. If user wish to apply modifiers after the simulation result, user can apply the modifiers to the Driven Shape instead of the simulation object. When Driven Shape is set, the simulation will export from the simulation object, but deforms the Driven Shape (instead of the simulation object).</p>"},{"location":"material-models/cloth/#cloth-material-models","title":"Cloth Material Models","text":"<p>Cloth objects can be one of two different type of materials, uv panel Baraff et. al. or elastic membrane Macklin et. al.</p>"},{"location":"material-models/cloth/#uv-panel","title":"UV panel","text":"<p>UV panel material follows the tailor style workflow. User can create cloth 2D patches, and use constraints to stitch the cloth patches together. In such case, the cloth rest shape is defined in 2D using UV parameters stored in hi_phy_cloth_uv attribute.</p> <p>In Blender, we provided a Convert UV button on the cloth object panel to convert the blender UV attribute to hi_phy_cloth_uv attribute. However, the cloth uv attribute is not 0 - 1 as the UV texture coordinate, but rather should be the physical coordinate of the cloth panel when lay flat on the UV plane. User can use addons such Magic UV to create a UV coordinate that matches the UV scale of cloth panels.</p> <p>Scaling the cloth panel</p> <p>Because the transformation of the 3D model can skew the surface of a mesh. We do not automatically adjust the cloth uv coordinate if the 3D model is scaled. To ensure the simulation works as intended, user need to manually adjust the cloth uv attribute to match the scaling of the cloth model.</p> Property Name Description Unit Is Mappable Is Animatable Stretch Stiffness U How much the panel resists stretching along the U direction \\(g/s^2\\) YES YES Stretch Stiffness V How much the panel resists stretching along the V direction \\(g/s^2\\) YES YES Stretch Damping Damping for the stretch motion \\(1/s\\) YES YES Sheer Stiffness How much the panel resists sheering \\(g/s^2\\) YES YES Sheer Damping Damping for the sheering motion \\(1/s\\) YES YES Bend Stiffness U How much the panel resists bend along the U direction \\(g*cm/s^2\\) YES YES Bend Stiffness V How much the panel resists bend along the V direction \\(g*cm/s^2\\) YES YES Bend Damping Damping for the bend motion \\(1/s\\) YES YES"},{"location":"material-models/cloth/#elastic-membrane","title":"Elastic Membrane","text":"<p>Elastic Membrane are material models that are rubber like. It can be used to simulate 2D surfaces that does not have a clear panel structure, such as gloves. UV parameters are not need for simulate elastic membranes</p> Property Name Description Unit Is Mappable Is Animatable Mu \\(\\mu\\) The first Lam\u00e9  parameter, shear modulus, \\(\\mu\\). It roughly corresponding to resistance to the shearing motion \\(g/s^2\\) YES YES Lambda \\(\\lambda\\) The second Lam\u00e9  parameter, shear modulus, \\(\\mu\\). It roughly corresponding to volume preservation \\(g/s^2\\) YES YES Mu Damping Damping for the shear motion \\(1/s\\) YES YES Lambda Damping Damping for the area changing (stretch) motions \\(1/s\\) YES YES Bend Stiffness V How much the panel resists bend along the V direction \\(g*cm/s^2\\) YES YES Bend Damping Damping for the bend motion \\(1/s\\) YES YES <p>Animating the material model</p> <p>The cloth material model is animatable. User can key the property and pick the material that fit the situation the best for each frame. However, each material has a seperate paramter set that user will need to tune. The two material models do share the same rest shape.</p>"},{"location":"material-models/cloth/#other-properties","title":"Other Properties","text":"Property Name Description Unit Is Mappable Is Animatable Target Stiffness The strength of the target shape pull \\(10\\mu N/cm = g/s^2\\) YES YES Target Damping Damping factor for target shape pull to prevent oscillation. \\(1\\) is critical damping Unitless YES YES Can Collide With Other Simulation Object Can this simulation object collide with other simulation objects YES YES Can Collide With Colliders Can this simulation object collide with kinematic colliders YES YES Gravity The gravitaional acceleration \\(cm/s^2\\) YES YES External Force Additional external force \\(10\\mu N = g*cm/s^2\\) YES YES Inner Thickness The thickness along the negative normal direction Model YES YES Outer Thickness The thickness along the positive normal direction Model YES YES Inner Friction Coefficient The friction coefficient for the inside Unitless YES YES Outer Friction Coefficient The friction coefficient for the outside Unitless YES YES Barrier Stiffness The stiffness of the collision barrier for contact \\(10\\mu N = g*cm/s^2\\) YES YES Density Surface density of the cloth object \\(g/cm^2\\) YES YES Relative Motion Damping Damping factor for relative motion between two adjacent vertices. \\(1/s\\) YES YES"},{"location":"material-models/cloth/#example","title":"Example","text":"<p>You can find the an example file for cloth simulation with UV panel materials here.</p> <p>You can find the an example file for cloth simulation with elastic membrane materials with resolution test here.</p> <p>Biased Triangulation</p> <p>Because HiPhyEngine requires all meshes to be triangulated, the regularity of the triangulation will creates a preferred bending direction on the material. Increasing resolution of the mesh, and randomize the triangulation can mitigate such artifacts.</p> <p>You can find a more complex example of an animated hand taking off a glove here. This example shows how user can use soft collider for the hands and cloth object for the glove, and even though the animation contains self intersection, HiPhyEngine is able to resolve the collision and create an intersection free result for both hands and the glove.</p> <p>The last example showcases a twisted cloth, and how HiPhyEngine handles layered contact. Note that for complex layered collisions, low frictional value can cause jitters. User might need to increase friction to stabilize the simulation. In this example, the simulation is stable for friction of value \\(1\\).</p>"},{"location":"material-models/deformable-body/","title":"Deformable Body","text":""},{"location":"material-models/deformable-body/#deformable-body","title":"Deformable Body","text":"<p>Deformable body is the material model for simulating elastic volumetric objects. Deformable body objects in Blender must be closed triangulated meshes. </p> <code>Solver</code> <p>The Solver object for the simulation.</p> <code>Target Shape</code> <p>During simulation, the Target Shape creates a force to pull the simulation object towards the Target Shape. It designed for achieving art directed shape during motion. The strength of the pulling force is controlled Target Stiffness and Target Damping parameter. Target Shape needs to have the same number of vertices as the simulation object.</p> <code>Driven Shape</code> <p>As noted in overview, in Blender, the simulation cache directly deforms the point attribute before any modifier is applied. While during export, all modifiers of the simulation object is applied. This means that having any modifiers on the simulation object that changes point position or vertex count on the simulation object will leads to a discrepancy between the simulation mesh and the simulation cache. Driven Shape is designed to bypass this limitation. If user wish to apply modifiers after the simulation result, user can apply the modifiers to the Driven Shape instead of the simulation object. When Driven Shape is set, the simulation will export from the simulation object, but deforms the Driven Shape (instead of the simulation object).</p> <code>Mesh Bone</code> <p>For simulating secondary motions of animated charaters, user will need to provide a mesh bone for the deformable body simulation. The mesh bone is, most commonly, is the animated mesh, displaced slightly along the negative normal direction of surface. The exact amount depends on the amount of secondary motion and deformation user wants. The more offset user use, more secondary motion and deformation the simulation will allow to have. Concepturally, mesh bone is just an internal target shape. mesh bone must be interior of the simulation mesh. However, it does not need to be intersection free or match the vertex count and topology of the simulation mesh. mesh bone can be significantly simplified for performance.</p>"},{"location":"material-models/deformable-body/#properties","title":"Properties","text":"Property Name Description Unit Is Mappable Is Animatable Target Stiffness The strength of the target shape pull \\(10\\mu N/cm = g/s^2\\) YES YES Target Damping Damping factor for target shape pull to prevent oscillation. \\(1\\) is critical damping Unitless YES YES Can Collide With Other Simulation Object Can this simulation object collide with other simulation objects YES YES Can Collide With Colliders Can this simulation object collide with kinematic colliders YES YES Gravity The gravitaional acceleration \\(cm/s^2\\) YES YES External Force Additional external force \\(10\\mu N = g*cm/s^2\\) YES YES Outer Thickness The thickness along the positive normal direction Model YES YES Friction Coefficient The friction coefficient for the deformable body Unitless YES YES Barrier Stiffness The stiffness of the collision barrier for contact \\(10\\mu N = g*cm/s^2\\) YES YES Density Density of the deformable object \\(g/cm^3\\) YES YES Mu \\(\\mu\\) The first Lam\u00e9  parameter, shear modulus, \\(\\mu\\). It roughly corresponding to resistance to the shearing motion \\(Pa = g/cm/s^2\\) YES YES Lambda \\(\\lambda\\) The second Lam\u00e9  parameter, shear modulus, \\(\\mu\\). It roughly corresponding to area preservation \\(Pa = g/cm/s^2\\) YES YES Mesh Bone Stiffness The strength of the mesh bone pull \\(10\\mu N/cm = g/s^2\\) YES YES Mesh Bone Damping Damping factor for mesh bone pull to prevent oscillation. \\(1\\) is critical damping Unitless YES YES <p>Mesh Bone Parameters</p> <p>Mesh bone parameters (Mesh Bone Stiffness and Mesh Bone Damping) are mappable. However, given mesh bone may be have different number of vertices as the simulation mesh, the maps (attributes) will live on the mesh bone instead of the simulation mesh. You can find an example of this map set up here. User can find more on maps in the property map section.</p>"},{"location":"material-models/deformable-body/#grid-embedding","title":"Grid Embedding","text":"<p>Deformable Body in HiPhyEngine is an implementation of the work by McAdams et. al.. It embeds the simulation in a hidden 3D grid. All deformable bodies share the same grid. Therefore the parameters related to the grid reside on the solver node.</p> <p>In the solver node, user can choose between the corotated linear elastic and stable NeoHookean model. corotated linear elastic is faster, but will suffer more volume loss with larger deformation. stable NeoHookean can handle large deformation better, but is slower. They share the same elastic parameters, and the material model attribute can be keyed and animated if needed.</p> <p>Grid Resolution</p> <p>Higher grid resolution will have a significant impact on the simulation performance. However, large grid size may lead to undesirable artifacts. For instance, if two mesh faces are rasterized in the same grid cell, the simulation will not be able to separate them. It will up to the user to try to see what resolution best fit each scene. For a general humanoid character, \\(1cm\\) cell size is a good start. However, it is worth noting that the grid cell size parameter is in model unit. It is intended for ease of measurement. If your character is about 100 units in the scene, and you set the grid cell size as 1, the resolution of the simulation grid of will be about 100. Please see the solver for more details on model unit.</p> <p>Furthermore, the HiPhyEngine uses a series of coarse to fine grid to speed up the simulation speed. The method is called the multigrid method. The performance of the multigrid of method deeply depends on the complexity of the mesh, if the mesh is regular such as round or cube shaped, the smallest grid can be 8x8x8 and the multigrid method can achieve very good performance, however, if the mesh has features such as thin limbs, the smallest grid size might need to be 16x16x16 or even 32x32x32 to capture those features. Once again, it will up to user to play with the setting to find the optimal solution for each scene. Luckily, even if the setting is not optimal, the simulator will still work, just it will take a bit longer to simulate. </p> <p>Here is the list of parameters on the solver that are related to the deformable body multigrid.</p> Property Name Description Unit Is Mappable Is Animatable Deformable Body Grid Cell Size The rasterization embeding cell size Model Deformable Body Multigrid Level Multigrid Level Deformable Body Smoothing Iteration Damping Damping factor for multigrid smoother YES Deformable Body Smoothing Iteration Smoother iteration for multigrid solver YES Deformable Body Bottom Smoothing Iteration Bottom Smoother iteration for multigrid solver YES <p>Smoother Damping and Iterations</p> <p>Those parameters are for more advanced users. For more details of the smoother, user can refer to the work by McAdams et. al.. But in most cases, user can leave smoothing iteration damping as what it is. If the deformable body simulation takes a lot of iterations to solve the CG system, user can increase smoothing iteration and bottom smoothing iteration to see if improves the convergence. They are animatable parameter as well. So user can choose to add more iterations for frames with more motions, while reducing them for more static frames.</p> <p>Multigrid Level</p> <p>To efficiently solve the elastic system, the multigrid method construct a hierarchy of grid each with half of the resolution of the previous level. The low resolution grid serves as a rough estimate for the fine level grid. If the simulation mesh is too complex, lower resolution will not be able to represent the mesh very well, and reduce the convergence rate. In practice, 16x16x16 or 32x32x32 for the lowest level resolution are good starting points, if user wish to tune the parameter for the best convergence behavior.</p>"},{"location":"material-models/deformable-body/#examples","title":"Examples","text":"<p>You can find the an example file for deformable body simulation here.</p> <p>An example file for a simple mesh bone set up can be find here. a version with a mapped mesh bone stiffness setup here.</p>"},{"location":"material-models/driven-shape/","title":"Driven shape","text":"<code>Driven Shape</code> <p>As noted in overview, in Blender, the simulation cache directly deforms the point attribute before any modifier is applied. While during export, all modifiers of the simulation object is applied. This means that having any modifiers on the simulation object that changes point position or vertex count on the simulation object will leads to a discrepancy between the simulation mesh and the simulation cache. Driven Shape is designed to bypass this limitation. If user wish to apply modifiers after the simulation result, user can apply the modifiers to the Driven Shape instead of the simulation object. When Driven Shape is set, the simulation will export from the simulation object, but deforms the Driven Shape (instead of the simulation object).</p>"},{"location":"material-models/elastic-rod/","title":"Elastic Rod","text":""},{"location":"material-models/elastic-rod/#elastic-rod","title":"Elastic Rod","text":"<p>Elastic rod is the material model for simulating curves. Elastic rod objects in Blender must be curves objects.</p> <code>Solver</code> <p>The Solver object for the simulation.</p> <code>Rest Shape</code> <p>The Rest Shape is the object for defining the shape at rest. The simulation object will returns to the Rest Shape when there is no external force. When no Rest Shape is specified, the start frame of the simulation object is used as the Rest Shape. Rest Shape needs to have the same number of vertices as the simulation object.</p> <code>Target Shape</code> <p>During simulation, the Target Shape creates a force to pull the simulation object towards the Target Shape. It designed for achieving art directed shape during motion. The strength of the pulling force is controlled Target Stiffness and Target Damping parameter. Target Shape needs to have the same number of vertices as the simulation object.</p> <code>Driven Shape</code> <p>As noted in overview, in Blender, the simulation cache directly deforms the point attribute before any modifier is applied. While during export, all modifiers of the simulation object is applied. This means that having any modifiers on the simulation object that changes point position or vertex count on the simulation object will leads to a discrepancy between the simulation mesh and the simulation cache. Driven Shape is designed to bypass this limitation. If user wish to apply modifiers after the simulation result, user can apply the modifiers to the Driven Shape instead of the simulation object. When Driven Shape is set, the simulation will export from the simulation object, but deforms the Driven Shape (instead of the simulation object).</p> <p>Poly line vs other curves types</p> <p>Elastic rod simulation object, and its driven shape must be poly curves objects. For driven shape this requirement is only true before applying any modifier or geometry nodes. User can use geometry node on the driven shape to convert the poly curves to other curve objects for rendering. See the last example for how to use geometry node on the driven shape to upsample the curves for rendering.</p>"},{"location":"material-models/elastic-rod/#material-properties","title":"Material Properties","text":"Property Name Description Unit Is Mappable Is Animatable Target Stiffness The strength of the target shape pull \\(10\\mu N/cm = g/s^2\\) YES YES Target Damping Damping factor for target shape pull to prevent oscillation. \\(1\\) is critical damping Unitless YES YES Can Collide With Other Simulation Object Can this simulation object collide with other simulation objects YES YES Can Collide With Colliders Can this simulation object collide with kinematic colliders YES YES Gravity The gravitational acceleration \\(cm/s^2\\) YES YES External Force Additional external force \\(10\\mu N = g*cm/s^2\\) YES YES Preloading Percentage The amount (0 - 1) for preloading (see the preloading section for more detail) Unitless YES Friction Coefficient The friction coefficient Unitless YES YES Barrier Stiffness The stiffness of the collision barrier for contact \\(10\\mu N = g*cm/s^2\\) YES YES Self Spring Collision Stiffness The stiffness of the rod-rod collision spring for contact (see the continuous collision section for more detail) \\(10\\mu N = g*cm/s^2\\) YES YES Self Spring Collision Damping Damping factor for rod-rod collision spring to prevent oscillation. \\(1\\) is critical damping Unitless YES YES Self Spring Collision Friction The friction coefficient for rod-rod collision spring Unitless YES YES Collision Radius Radius of collision for the rod Model Unit YES YES Density Line density of the elastic rod \\(g/cm\\) YES YES Stretch Stiffness How much does the rod resists stretch \\(10\\mu N/cm = g/s^2\\) YES YES Stretch Damping Damping factor for stretch force. (1 is critical damping) Unitless YES YES Bend Stiffness How much does the rod resists bend \\(10\\mu N/rad = g/s^2/rad\\) YES YES Bend Damping Damping factor for bend force. \\(10\\mu N/g = cm/s^2\\) YES YES Twist Stiffness How much does the rod resists twist \\(10\\mu N/rad = g/s^2/rad\\) YES YES Twist Damping Damping factor for twist force. \\(1/(cm^2s^2)\\) YES YES Relative Motion Damping Damping factor for relative motion between two adjacent vertices. \\(1/s\\) YES YES Mass Damping Damping factor for all motions, except for twists \\(1/s\\) YES YES Moment of Inertia Damping Damping of all twist motion \\(1/s\\) YES YES <p>Model Unit</p> <p>Model units are special units that does not scale with the solver scale. See solver section for more detail.</p> <p>Density</p> <p>Rod density is computed using per unit length, not the volume. Collision radius of the rod does not affect the rod mass.</p> <p>Friction Coefficient</p> <p>Friction coefficients are multiplicative. If a surface with friction coefficient \\(0.1\\) comes in contact with another surface of friction coefficient \\(0.1\\), the resulting friction coefficient is \\(0.1 \\times 0.1 = 0.01\\)</p> <p>Barrier vs Spring contact</p> <p>Contacts between rod and rod are handled by springs instead of barriers, while contacts between rod and collider and other types of objects are handled by barriers. Therefore, we have two seperate set of parameters Self Spring Collision Stiffness\\Damping\\Friction and Barrier Stiffness to control different contacts.</p>"},{"location":"material-models/elastic-rod/#parameterization","title":"Parameterization","text":"<p>HiPhyEngine supports expression languages such as SeExpr2. In some cases, use might want to use the $t expression to procedurally generate a map for a given attribute.</p> <p>The Add parameterization attribute to curve button creates an attribute on the curve that can be used by the expression later. See expression for details on how the parameter is used in the expressions.</p>"},{"location":"material-models/elastic-rod/#curves-order","title":"Curves Order","text":"<p>Similar to all meshes in HiPhyEngine are linear elements (triangles), Curves in HiPhyEngine are linear segments. If the curves are created from a higher order discretization, please make sure the simulation curve is a poly curves object and has enough resolution to capture the original shape.</p>"},{"location":"material-models/elastic-rod/#base-normal","title":"Base Normal","text":"<p>As one dimensional shapes, line segments can freely rotates around its edge without introducing any deformation. To disambiguate this symmetry, we need to introduce the concept of frame normals to the line segments. Therefore, when the line segment rotates around its edge, the frame normal rotates around the edge as well. It allows us to differentiate the line segment and rotated line segments as two different configurations.</p> <p>In practice, what the frame normal is, is of little importance, as long as it is perpendicular to the edge.</p> <p>The Add base normal to curve button automatically creates the base normal attribute on the curves objects. Without the base normal attribute, curves can not be used HiPhyEngine simulation.</p>"},{"location":"material-models/elastic-rod/#root-constraint","title":"Root Constraint","text":"<p>Given the required special base normal on the elastic rod objects, when constraining the elastic rod objects, we also need to constrain the base normal to prevent the elastic rods freely rotating along its edges. Root constraint constraints not only the position but the base normal of the elastic rods.</p> <p>To create a root constraint in Blender, select the curves and the mesh you wish the root of the curves to anchor to, in Object Mode, choose, Hi Phy Create Root Constraint in the pop up menu. It will create a constraint that binds the position and base normal of the first vertex of each curve to the mesh.</p>"},{"location":"material-models/elastic-rod/#preloading","title":"Preloading","text":"<p>Under gravity and other external forces, elastic rods can undergo large amount of deformation and fails to maintain its designed shapes. The preloading process computes the rest shape that compensates the external forces, so the elastic rods can maintain it's designed shape. In contrast to using target shapes which can create unnatural motions, preloading creates more fluid results. However, preload to full can result in a floaty motion. It is advised to use a map for Preloading Percentage to preload less on the root or the rods and more on the tip the rods.</p> <p>Preloading can only maintain the static designed shape. For hitting key shapes in motion, target shapes is still the best way to achieve that.</p> <p>Preloading process modifies the rest shape object. Similar to the restriction on the simulation object, if user wish to use the preloading process, please make sure there is no modifier stack on the rest shape that changes the vertex positions or the topology.</p> <p>Preloading curves button lives on the solver object. The preloading process gradually increases the force on the curves in the number of steps dictated by the curve preloading substeps. curve preloading substeps also defines the resolution of the Preloading Percentage parameter. By default, the preloading process takes 100 substeps, so Preloading Percentage has an effective resolution of 0.01.</p>"},{"location":"material-models/elastic-rod/#continuous-time-collision","title":"Continuous Time Collision","text":"<p>Unlike meshes, curves are line segments that do not have a self-intersecting state. However, during simulation, curves can still pass each other. In the case of curves, such scenario will not lead to a self-intersecting invalid state for the simulator. Therefore, we allow user to turn off continuous time collision for elastic rods as a global solver setting.</p>"},{"location":"material-models/elastic-rod/#examples","title":"Examples","text":"<p>You can find the an example file for elastic rod simulation here.</p> <p>You can find the an example file for elastic rod preloading here.</p> <p>Settling before preloading</p> <p>Settling after preloading</p> <p>An example of coupling elastic rod and affine body can be find here.</p> <p>HiPhyEngine is able to accurately resolve all collisions. It allows affine bodies to slide between the elastic rods gaps. Despite of the high velocity impact, the weave pattern of the rods is maintained from HiPhyEngie's intersection free guarantee. In this example, we also demonstrate how to use geometry node on the driven shape to upsample the simulation results for rendering.</p>"},{"location":"material-models/material-models/","title":"Material Models","text":""},{"location":"material-models/material-models/#hiphyengine-material-models","title":"HiPhyEngine Material Models","text":"<p>HiPhyEngine supports full coupling of multiple different material models. Picking the right material model for the right phenomenal is crucial to get a stable simulation result that fits your expectation. For Lagrangian simulation, HiPhyEngine supports 6 different material models: Affine Body, Elastic Rod, Cloth, Deformable Body, Kinematic Collider, and Soft Collider.</p>"},{"location":"material-models/material-models/#affine-body","title":"Affine Body","text":"<p>Affine Body in HiPhyEngine is an implementation of the work by Lan et. al.. It is designed for simulating very stiff objects while holding many advantages over rigid bodies mathematically. For the purpose of the simulation setup, they can be treated as the material models for rigid objects.</p>"},{"location":"material-models/material-models/#elastic-rod","title":"Elastic Rod","text":"<p>Elastic Rod in HiPhyEngine is an implementation of the work by Bergou et. al.. Different from a traditional spring-based system, a single elastic rod can resist twist and bend, which makes them ideal for simulation hair (especially curls) and other type of thin threads that have a innate curvy structure that needs to be maintained in simulation.</p>"},{"location":"material-models/material-models/#cloth","title":"Cloth","text":"<p>Cloth in HiPhyEngine is an implementation of the work by Baraff et. al. and Macklin et. al.. It can be used to simulate soft fabric materials.</p>"},{"location":"material-models/material-models/#deformable-bodies","title":"Deformable Bodies","text":"<p>Deformable Body in HiPhyEngine is an implementation of the work by McAdams et. al. and Smith et. al.. It simulates the stable Neo-Hookean material model, with a multigrid solver. It can be used for soft 3D objects like elastic objects, muscles, and soft tissues for volume conservation and create secondary motions.</p>"},{"location":"material-models/material-models/#kinematic-collider","title":"Kinematic Collider","text":"<p>Kinematic Colliders are standard collision objects. They are directly taken from the animation, the simulator will not deform them.</p>"},{"location":"material-models/material-models/#soft-collider","title":"Soft Collider","text":"<p>With animation, it is extremely difficult to create intersection free input for simulations. Without modifications, those collision objects can lead to failed simulation because there is no intersection free solution. HiPhyEngine not only guarantees but requires (unless collision is turned off) the simulation meshes and colliders to be intersection free. Soft colliders are designed to resolve self intersection in colliders from animation input with minimal changes to the silhouette. In contrast to cloth or deformable body, soft collider has carries no momentum. There is be no secondary motion, volume preservation, only intersection resolution for soft colliders.</p>"},{"location":"material-models/mesh-bone/","title":"Mesh bone","text":"<code>Mesh Bone</code> <p>For simulating secondary motions of animated charaters, user will need to provide a mesh bone for the deformable body simulation. The mesh bone is, most commonly, is the animated mesh, displaced slightly along the negative normal direction of surface. The exact amount depends on the amount of secondary motion and deformation user wants. The more offset user use, more secondary motion and deformation the simulation will allow to have. Concepturally, mesh bone is just an internal target shape. mesh bone must be interior of the simulation mesh. However, it does not need to be intersection free or match the vertex count and topology of the simulation mesh. mesh bone can be significantly simplified for performance.</p>"},{"location":"material-models/preload-reference-shape/","title":"Preload reference shape","text":"<code>Preload Reference Shape</code> <p>During simulation, external force such as gravity will change the designed shape. The preloading process solves the rest shape needed to maintain the preload reference shape under the given external force. See preloading for more detail.</p>"},{"location":"material-models/rest-shape/","title":"Rest shape","text":"<code>Rest Shape</code> <p>The Rest Shape is the object for defining the shape at rest. The simulation object will returns to the Rest Shape when there is no external force. When no Rest Shape is specified, the start frame of the simulation object is used as the Rest Shape. Rest Shape needs to have the same number of vertices as the simulation object.</p>"},{"location":"material-models/soft-collider/","title":"Soft Collider","text":""},{"location":"material-models/soft-collider/#soft-collider","title":"Soft Collider","text":"<p>Collision objects coming from animation usually will contain self intersection and cause issues for simulations. Soft collider is the material model designed for de-intersecting the collision objects while maintaining the silhouette as much as possible. Soft collider has carries no momentum, therefore will create no secondary motions. Soft colliders in Blender must be triangulated meshes.</p> <code>Solver</code> <p>The Solver object for the simulation.</p> <code>Target Shape</code> <p>During simulation, the Target Shape creates a force to pull the simulation object towards the Target Shape. It designed for achieving art directed shape during motion. The strength of the pulling force is controlled Target Stiffness and Target Damping parameter. Target Shape needs to have the same number of vertices as the simulation object.</p> <code>Driven Shape</code> <p>As noted in overview, in Blender, the simulation cache directly deforms the point attribute before any modifier is applied. While during export, all modifiers of the simulation object is applied. This means that having any modifiers on the simulation object that changes point position or vertex count on the simulation object will leads to a discrepancy between the simulation mesh and the simulation cache. Driven Shape is designed to bypass this limitation. If user wish to apply modifiers after the simulation result, user can apply the modifiers to the Driven Shape instead of the simulation object. When Driven Shape is set, the simulation will export from the simulation object, but deforms the Driven Shape (instead of the simulation object).</p>"},{"location":"material-models/soft-collider/#properties","title":"Properties","text":"Property Name Description Unit Is Mappable Is Animatable Inner Thickness The thickness along the negative normal direction Model YES YES Outer Thickness The thickness along the positive normal direction Model YES YES Can Collide With Other Simulation Object Can this simulation object collide with other simulation objects YES YES Can Collide With Colliders Can this simulation object collide with kinematic colliders YES YES Inner Friction Coefficient The friction coefficient for the inside Unitless YES YES Outer Friction Coefficient The friction coefficient for the outside Unitless YES YES Barrier Stiffness The stiffness of the collision barrier for contact \\(10\\mu N = g*cm/s^2\\) YES YES Goal Stiffness How strong the soft collider conforms to the target shape when there is contact \\(g\\) YES Fall Off Influence When in contact, and forced to defrom, this parameter influece how far the contact deformation will smooth out \\(10\\mu N/cm = g/s^2\\) YES <p>Can Collide With Other Simulation Object/Colliders</p> <p>For collision purposes, soft colliders are simulation objects, not kinematic colliders. To control collision with soft colliders, use the parameter Can Collide With Other Simulation Object.</p> <p>Goal Stiffness</p> <p>Goal Stiffness has a unit of mass (\\(g\\)). It can be interperated as how heavy a vertex is. When two soft collider vertices comes into contect, the heavier vertex will give in less, while the lighter vertex will give in more. This parameter is mappable, but not animatable.</p> <p>Fall Off Infleunce</p> <p>When vertices comes into contact, it often creates a sharp and irregular shape. The Fall Off Infleunce parameter controls how much a contact will influece nearby vertices. Larger the value, more the contact will be smoothed out. This parameter is mappable, but not animatable.</p>"},{"location":"material-models/soft-collider/#examples","title":"Examples","text":"<p>You can find the a simple soft collider example file here.</p> <p>Before soft collider simulation</p> <p>After soft collider simulation</p> <p>You can find the an example for using soft collider to resolve intersection from animation here. The arm is use a simple two joint rig with automatic generated weights. This example also demonstrates how to use the a painted map and geometry nodes to create attributes (in this case, Outer Thickness), that can be used by the simulator.</p> <p>After soft collider simulation</p> <p>On volume perservation</p> <p>Soft collider does minimal local surface deformation. It is good at preserving siluette but provides no volume preservation. If user wish to have volume perservation, please use deformable body instead.</p> <p>On the number of substeps</p> <p>If soft collider is used in isolation to clean up animated mesh. The default 10 substeps per frame is usually far too many, given there is no dynamics for the soft colliders. User can go as low as 1 substeps per frame. However, reduce substeps might leads to jitter. In such cases, user might need to increase frame rate, time scale, or increase substeps. It is a balance act between simulation stability and number substeps. See solver for more details on substeps, frame rate, and time scale.</p>"},{"location":"material-models/solver-node/","title":"Solver node","text":"<code>Solver</code> <p>The Solver object for the simulation.</p>"},{"location":"material-models/target-shape/","title":"Target shape","text":"<code>Target Shape</code> <p>During simulation, the Target Shape creates a force to pull the simulation object towards the Target Shape. It designed for achieving art directed shape during motion. The strength of the pulling force is controlled Target Stiffness and Target Damping parameter. Target Shape needs to have the same number of vertices as the simulation object.</p>"},{"location":"overview/how-hiphyengine-blender-addon-works/","title":"How HiPhyEngine Blender Addon Works","text":""},{"location":"overview/how-hiphyengine-blender-addon-works/#how-hiphyengine-blender-addon-works","title":"How HiPhyEngine Blender Addon Works","text":"<p>HiPhyEngine is a standard Python addon for Blender. It gets and sets the scene data through only the Blender Python API. Due to this constraint, there is a few limitations on how the simulation rigs can be set up.</p>"},{"location":"overview/how-hiphyengine-blender-addon-works/#scene-export","title":"Scene Export","text":"<p>When a simulation is kicked off HiPhyEngine solver will go through the timeline one frame at a time and export all relevant scene objects. This process will use the final evaluated object from the editor, so only modifiers visible in the editor will be picked up.</p>"},{"location":"overview/how-hiphyengine-blender-addon-works/#simulation-deformation","title":"Simulation Deformation","text":"<p>When bringing back the result of the simulation, due to the limitation of Blender's Python API, HiPhyEngine can not deform the simulation object at the end of the modifier chain. The deformation of the position attribute from the simulator will be applied at the start of the modifier chain. It means that any modifier that changes the position or topology of the simulation object will cause issues.</p> <p>Therefore, simulation objects for HiPhyEngine needs to have a minimal modifier chain (triangulate is one of the few modifiers that is ok to use). If you wish to apply modifier chains after the simulator, you need to create a second object, and use the simulation object to deform the second object, and apply your desired modifier chain on the second object after the deform modifier. The Driven shape is designed circumvent such limitation.</p>"},{"location":"overview/how-hiphyengine-blender-addon-works/#simulation-cache-management","title":"Simulation Cache Management","text":"<p>Due to the potential large size of the simulation cache, we decided not to automatically save the cache whenever blender is saved to prevent frequent slowdowns and disk i/o during saves for large scale simulations. User will have to manually save/load the cache use the provided button on the solver node and operator calls. It also leaves the potential for users to create scripts to version-manage simulation caches, without worrying that the HiPhyEngine automatically overrides the simulation cache files when saving the Blender file.</p>"},{"location":"quick-start/quick-start-blender/","title":"Blender Quick Start","text":""},{"location":"quick-start/quick-start-blender/#hiphyengine-blender-quick-start","title":"HiPhyEngine Blender Quick Start","text":""},{"location":"quick-start/quick-start-blender/#system-requirement","title":"System Requirement","text":"<p>HiPhyEngine supports Windows and Linux. It requires an x64 CPU with AVX2 support. Any Intel/AMD CPU from last decade should be enough. HiPhyEngine requires installation of third party packages through pip.</p>"},{"location":"quick-start/quick-start-blender/#install-addon","title":"Install Addon","text":"<p>HiPhyEngine can be installed through the add on menu(edit-&gt;preferences-&gt;Add-ons)</p> Install Menu <p>For the first time HiPhyEngine is loaded, it will automatically install its dependancy Intel's MKL and PyBind11 using pip. Blender's python manages its own enviroment, and those packages will be only installed with Blender's python enviroment. Due to those installations, the first time loading HiPhyEngine can take a seconds to a few minutes depending on the network connection. User can check the download progress on the terminal/console.</p> <p>Note</p> <p>HiPhyEngine is currently complying to the VFX2025 standard. Specifically, Python 3.11. It is comes with Blender 4.5+.</p>"},{"location":"quick-start/quick-start-blender/#creating-your-first-simulation-setup","title":"Creating Your First Simulation Setup","text":"<p>In this section, we will show user how to set up a simple rigid body (affine body) simulation.</p> <p>After insallation, HiPhy panel will show in the physics menu.</p> <p>By checking Hi Phy, it enables HiPhyEngine on the selected object.</p> <p>The panel lists the different supported materials and nodes for HiPhyEngine. For this tutorial, we will use the Lagrangian Solver, Affine Body, and Collider.</p>"},{"location":"quick-start/quick-start-blender/#creating-affine-bodies","title":"Creating Affine Bodies","text":"<p>Create two cubes and places them above each other for some interesting collision.</p> <p>Enable Hi Phy in the Physics panel and select Affine Body as the material model.</p> <p>Note</p> <p>Affine Bodies are material models for simulating very stiff objects. From the simulator's perspective, they are preferred over rigid bodies for their mathematical properties. For the purpose of simulation setup, they can be treat as rigid bodies without differentiation.</p> <p>In the Modifiers panel, add a Triangulate modifier to both cubes. Check the Keep Normals option to ensure the normals are preserved by the triangulation.</p> <p>Note</p> <p>All meshes in HiPhyEngine simulation must be triangle meshes. To ensure maximum transparency, HiPhyEngine does not perform any internal triangulation, so the simulation mesh will always matches what is in the scene.</p> <p>Also change the Gravity property on the affine bodies from [0, -980, 0] to [0, 0, -980].</p> <p>z-up vs y-up</p> <p>HiPhyEngine is generally coordinate system agnostic, besides the Gravity property. Even though Blender is default z-up, we choose to be y-up to be consistent with industry standard to make it easier working with assets from other packages.</p> <p>Unit</p> <p>The unit of length in HiPhyEngine is cm. There is a Solver Scale property on the solver node for convert units if the scene unit is not cm.</p>"},{"location":"quick-start/quick-start-blender/#creating-a-collider","title":"Creating A Collider","text":"<p>Create a plane and scale it up and move it below the cubes. Enable Hi Phy and select Collider. Don't forget to triangulate it as well.</p>"},{"location":"quick-start/quick-start-blender/#creating-a-solver","title":"Creating A Solver","text":"<p>A solver node is in charge of gathering the information of all the simulation objects connected to the solver, running the simulation and maintaining the cache for simulation.</p> <p>Create an empty plane axis (or any invisible object you prefer). Enable Hi Phy and select Lagrangian Solver.</p>"},{"location":"quick-start/quick-start-blender/#connect-objects-to-the-solver","title":"Connect Objects To the Solver","text":"<p>The last thing you need to do, is to connect the simulation objects to the solver.</p> <p>In the Hi Phy panel, assign the solver node to the Solver property for the two affine bodies and the collider.</p>"},{"location":"quick-start/quick-start-blender/#running-the-simulation","title":"Running The Simulation","text":"<p>Click the Run Sim button on the solver node's Hi Phy panel, the simulation will be kicked off asynchronously. You can see the progress of the simulation under the Run Sim button.</p> <p>You can change the frames on the timeline. The simulation meshes will be updated with frame change when the simulation frames are available.</p> <p>Congratulation on your first HiPhy simulation!</p> <p>You can find the reference file here</p>"}]}